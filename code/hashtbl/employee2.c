/*************************************************************************
  Avoiding collisions using Chaining.

  Pictorial Representation
  Table nodes   nodes
    []   
    []     _       _
    [] -->|_| --> |_|       
    []
    []     _       _      _
    [] -->|_| --> |_| -->|_|             

   Author: Vikas Nagpal : http://anuttaralearning.com/
*************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_STR_LENGTH 20
#define HASH_TBL_SIZE 10  //Hash Table Size

/* Structure to store employee details */
typedef struct employee_info
{
  int    id;
  char   name[MAX_STR_LENGTH];
  char   group[MAX_STR_LENGTH];
  struct employee_info * next;
}employee_info_t;

/* Function Prototypes */
int hash_function(int id);
employee_info_t *create_node(int emp_id, char *emp_name, char *emp_group);
void insert(int emp_id, char *emp_name, char *emp_group, employee_info_t *employee[]);
void delete(int emp_id, employee_info_t *employee[]);
void search(int emp_id, employee_info_t *employee[]);
void display(employee_info_t *employee[]);
void free_memory(employee_info_t *employee[]);

/* Main function starts */
int main(int argc, char *argv[])
{
  employee_info_t *employee[HASH_TBL_SIZE] = {NULL}; //Hash Table

  printf("Inserting John(5), Kevin(4) and Ricky(15)\n");
  insert(5, "John", "Engg", employee);
  insert(4, "Kevin", "IT", employee);
  insert(15, "Ricky", "FIN", employee); //Collision

  printf("Searching for id 15\n");
  search(15, employee);
  printf("Searching for id 5\n");
  search(5, employee);
  display(employee);

  printf("Deleting id(s) 15 and 4\n");
  delete(15, employee);
  delete(4, employee);
  display(employee);

  /* Freeing memory, before exit */
  free_memory(employee);
  return 0;
}
            
/*************************************************************
  Function : create_node 
  Creates a node of employee_info_t type.

  Parameters : Employee id, Name, Group

  Returns pointer to  the created node
*************************************************************/
employee_info_t *create_node(int emp_id, char *emp_name, char *emp_group)
{
  employee_info_t *new_node = (employee_info_t *)malloc(sizeof(employee_info_t));
  if(NULL == new_node)
  {
    printf("Malloc Error\n");
    exit(1);
  }

  new_node->id = emp_id;
  strcpy(new_node->name, emp_name);
  strcpy(new_node->group, emp_group);
  new_node->next = NULL;
  
  return new_node;
}

/*************************************************************
   Hash Function
   Parameter : Employee id
   Returns   : an index in the table
*************************************************************/
int hash_function(int id)
{
  return id % HASH_TBL_SIZE;
}
          
        
/**************************************************************************************
Function inserts employee info by creating a new node.
The index generated by the hash function points to this node.
If a collision occurs, the new node is added at the beginning 
of the list starting from that index.
***************************************************************************************/
void insert(int emp_id, char *emp_name, char *emp_group, employee_info_t *employee[])
{
  int index;
  employee_info_t *new_node = NULL;
           
  new_node = create_node(emp_id, emp_name, emp_group);  
  
  index = hash_function(emp_id); 

  printf("Inserting emp_id=%d at index %d\n", emp_id, index);

  // Logic to insert node at beginning of the linked list in bucket
  if(NULL == employee[index])
  {
    employee[index] = new_node;
    printf("Added the first node in that bucket\n");
  }
  else // Collision
  {
    /* Inserting at the beginning of the list */
    new_node->next = employee[index];
    employee[index]= new_node; 
    printf("Added another node in that bucket\n");
  }
}
  
/****************************************************************************
  Function deletes employee details for a given employee id from the hash
  table. 
****************************************************************************/
void delete(int emp_id, employee_info_t *employee[])
{
  int index;
  employee_info_t *head = NULL, *ptr = NULL, *prev = NULL;  

  index = hash_function(emp_id);
  head = employee[index];

  // Basically, the below code is doing deletion of a first/middle/last node from a linked list 

  /*Check if employee info to be deleted in the first node of the list */
  if (head->id == emp_id)
  {
    printf("Deleted details of employee with id- %d\n",head->id);
    employee[index] = head->next;
    free(head);
    return ;
  }
             
  /* If not the first node, then traversing the list to check which 
  node to delete at the generated index */
  ptr = head;
  while(ptr != NULL && ptr->id != emp_id)
  {
    prev = ptr;
    ptr = ptr->next;
  }

  if (ptr == NULL) // Searched the whole list, Employee info not in table 
    printf("No Such Entry in the Table\n");
  else // Employee details found , deleting that node 
  {
    printf("Deleted details of employee with id- %d\n", ptr->id);
    prev->next = ptr->next;
    free(ptr);
  }
}
  
/****************************************************************************
  Function searches for employee details for a given employee id in the hash 
  table.
****************************************************************************/
void search(int emp_id, employee_info_t *employee[])
{
  int index;
  employee_info_t *ptr = NULL; 

  index = hash_function(emp_id);

  ptr = employee[index]; // starting at head

  /* Traversing the list to find the entry at the generated index  */
  while(ptr != NULL && ptr->id != emp_id)
    ptr = ptr->next;

  if(ptr == NULL) // Employee info not in table 
    printf("No Such Entry in the Table\n");
  else // Employee details found 
  {
    printf("Found at index %d\n",index);
    printf("%d\t%s\t%s\n",ptr->id, ptr->name, ptr->group);
  }
}
  
/***********************************************************************************
  Function to display the hash table
************************************************************************************/
void display(employee_info_t *employee[])
{
  int index;
  employee_info_t *ptr = NULL;

  for(index = 0; index < HASH_TBL_SIZE; index++)
  {
    printf("row[%d]  -- ",index +1);
    ptr = employee[index];
    while(NULL != ptr)
    {
      printf("|%d\t%s\t\t%s|\t",ptr->id,ptr->name,ptr->group);
      ptr = ptr->next;
    }       
    printf("\n");
  }
}

/**********************************************************************************
  Function to free all the dynamically allocated memory
**********************************************************************************/
void free_memory(employee_info_t *employee[])
{
  int index;
  employee_info_t *ptr = NULL,*prev_node = NULL ;

  for(index = 0; index < HASH_TBL_SIZE; index++)
  {
    ptr = employee[index];

    /* Traverse the whole list at that index */
    while(NULL != ptr)
    {
      prev_node = ptr;
      ptr = ptr->next;
      free(prev_node);
    } 
  }
}
